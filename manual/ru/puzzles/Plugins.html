<!DOCTYPE html>
<html lang="ru">
  <head>
    <title>Пазлы Плагинов - Soft8Soft</title>
    <meta charset="utf-8">
    <meta name="description" content="Пользовательские плагины для пазлов Verge3D."/>
    <base href="../../../" />
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css" />
  </head>
  <body><article>

    <h1>Плагины</h1>

    <p>
        <a href="manual/ru/introduction/Puzzles-Visual-Logic-Editor.html">Редактор пазлов Verge3D</a>
         предоставляет возможность загрузки собственных пользовательских пазлов, что позволяет расширить функциональность редактора за счет функций, о которых вы всегда мечтали. 
    </p>


    <h2>Содержание</h2>

    [contents]


    [anchor:installing]

    <h2>Установка Плагинов</h2>

    <p>
        Плагины - это каталоги с большим количеством файлов, относящихся к плагинам. Они должны быть помещены в папку *puzzles/plugins* в Verge3D для того, чтобы они были распознаны редактором пазлов. И это все! После перезагрузки страницы редактора все установленные плагины должны появиться в нижней части панели инструментов редактора сразу после всех стандартных категорий пазлов.
    </p>

    <img src="files/puzzles/puzzles-plugins-ui-location.jpg" class="centered" style="max-width: 570px">
    <span class="img-caption">Plugin categories in the toolbox</span>

    <p id="example_plugin" class="note">
        <u>Для разработчиков пазлов</u><br/>
        
        Этот полезный плагин содержит примеры некоторых типичных блоков пазлов: <a href="files/puzzles/ExamplePlugin.zip">ExamplePlugin.zip</a>. Просто распакуйте его в папку *puzzles/plugins*, а затем ознакомьтесь с категорией пазлов "Example Plugin".
    </p>


    [anchor:plugin_files_overview]

    <h2>Обзор Файлов Плагинов</h2>

    Типичный плагин представляет собой каталог с файлом *init.plug*, содержащим общие настройки с большим количеством файлов <b>*.block</b>, каждый из которых определяет один блок пазла. Если ваш текстовый редактор поддерживает подсветку синтаксиса, то режим HTML должен хорошо работать для обоих форматов файлов.
    [anchor:init_plug_file_format]

    <h3>Формат файла init.plug </h3>

    <p>
        *init.plug* - это обязательный файл плагина, который используется для задания общих настроек. В этом файле вы можете определить, как выглядит запись панели инструментов. Также вы можете добавить туда некоторый предварительный код javascript для ваших пазлов. Вот простой пример того, что вы можете увидеть в файле *init.plug*:
    </p>

    <code>
    &lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;label text="My Awesome Plugin v1.0"&gt;&lt;/label&gt;
        &lt;block type="myPuzzle"&gt;&lt;/block&gt;
        &lt;block type="doSomethingCool"&gt;&lt;/block&gt;
    &lt;/category&gt;

    &lt;script&gt;
    function code() {
        return `console.log('Powered by My Awesome Plugin!');`;
    }
    &lt;/script&gt;
    </code>


    [anchor:init_plug_category]

    <h4>Category</h4>

    <p>
        Часть *category* представляет собой XML-дерево, которое определяет, как плагин и его блоки пазлов будут отображаться в панели инструментов редактора пазлов. Хотя она и необязательна, но если вы не добавите ее в файл *init.plug*, то плагин вообще не будет загружен.
        
        <br/><br/>
        Существует несколько вариантов, которые можно настроить через *category*:
    </p>


    [anchor:init_plug_toolbox_entry_name]

    <h5>Имя панели инструментов</h5>

    <p class="indented">
        Указывается через атрибут *name*:
        <code>
&lt;category name="My Awesome Plugin"&gt;&lt;/category&gt;
        </code>
    </p>


    [anchor:init_plug_toolbox_entry_color]

    <h5>Цвет панели инструментов</h5>

    <p class="indented">
        Указывается с помощью атрибута *color*: 
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;&lt;/category&gt;
        </code>
        Цвет может быть задан в одном из следующих форматов:
    </p>

    <ul id="color_formats">
        <li>
            hex triplet, например <b>#f61</b> или <b>#f0562f</b>
        </li>
        <li>
            значение оттенка в диапазоне 0°-360° (в рамках цветовой модели HSV с S и V, установленными на 45% и 65% соответственно), например, <b>140</b>
        </li>
        <li>
            цветовые ключевые слова, такие как <b>aqua</b>, <b>black</b>, <b>blue</b>,
            <b>fuchsia</b>, <b>gray</b>, <b>green</b>, <b>lime</b>,
            <b>maroon</b>, <b>navy</b>, <b>olive</b>, <b>purple</b>,
            <b>red</b>, <b>silver</b>, <b>teal</b>, <b>white</b> и
            <b>yellow</b>
        </li>
    </ul>


    [anchor:init_plug_available_puzzles]

    <h5>Доступные Пазлы</h5>

    <div class="indented">
        <p>
            Чтобы сделать блок пазла доступным в категории инструментов плагина, он должен быть указан через элемент *block* и его атрибут *type*. Атрибут *type* может ссылаться на такие пазлы, как:
        </p>

        <ul>
            <li id="available_puzzles_plugin">
                пазлы, определяемые самим плагином - в этом случае *type* должен быть установлен в соответствии с именем соответствующего .block файла внутри каталога вашего плагина (например, *myPuzzle* для файла блока *my_awesome_plugin/myPuzzle.block*)
                <code>
    &lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;&lt;/block&gt;
    &lt;/category&gt;
                </code>
            </li>
            <li id="available_puzzles_stock">
                блоки стоковых пазлов - *type* должен быть равен типу стокового пазла(например, *math_number*). Это позволяет добавлять стоковые пазлы непосредственно в категорию инструментов вашего плагина
                <code>
    &lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="math_number"&gt;&lt;/block&gt;
    &lt;/category&gt;
                </code>
            </li>
            <li>
                пазлы, определенные другими плагинами - *type* должен быть в форме *PLUGIN_DIRECTORY_NAME/PUZZLE_TYPE*. Например, на пазлы из стандартного плагина <a href="manual/ru/puzzles/ECommerce.html">E-Commerce</a> можно ссылаться следующим образом:
                <code>
    &lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="E-Commerce/placeOrder"&gt;&lt;/block&gt;
    &lt;/category&gt;
                </code>
            </li>
        </ul>

        <p id="puzzle-xml-tree">
            Чтобы узнать тип определенного блока пазла, можно воспользоваться опцией "Print Puzzle XML Tree" из контекстного меню пазла:
        </p>
        <img src="files/puzzles/puzzles-plugins-print-puzzle-xml-tree.png" class="width-clear border-gray">

        <p>
            Этот пункт меню выводит дерево XML пазла в консоль браузера. В нем можно найти тип пазла, а также всю структуру XML, что может пригодиться при установке <a href="manual/ru/puzzles/Plugins.html#init_plug_default_input_field_values">значений по умолчанию для полей ввода</a>.
        </p>
        <img src="files/puzzles/puzzles-plugins-puzzle-xml-tree.png" class="width-clear border-gray">

        <p>
            Опция меню "Print Puzzle XML Tree" обеспечивает простой способ добавления в ваш плагин сразу целой группы блоков пазлов. Это полезно для создания своего рода "snippets", состоящих из связанных блоков пазлов, и помещения их в ваш плагин, что делает его немного похожим на  <a href="manual/ru/puzzles/Library.html">Библиотеку пазлов</a>.

            <p>
                Следующий пример объясняет, как это сделать: :
            </p>
            <ul>
                <li>
                    создайте несколько блоков пазлов в Редакторе Пазлов:<br/>
                    <img src="files/puzzles/puzzles-plugins-puzzle-xml-tree-step-1.png" class="width-clear border-gray">
                </li>
                <li>
                    щелкните правой кнопкой мыши на самом верхнем/самом крайнем блоке и выберите "Print Puzzle XML Tree":<br/>
                    <img src="files/puzzles/puzzles-plugins-puzzle-xml-tree-step-2.png" class="width-clear border-gray">
                </li>
                <li>
                    перейдите в консоль браузера и скопируйте напечатанный элемент (вот как это выглядит в Google Chrome):<br/>
                    <img src="files/puzzles/puzzles-plugins-puzzle-xml-tree-step-3.png" class="width-clear border-gray">
                </li>
                <li>
                    вставьте его в файл *init.plug* внутри элемента <b>&lt;category&gt;</b>
                    и сохраните файл:<br/>
                    <img src="files/puzzles/puzzles-plugins-puzzle-xml-tree-step-4.png" class="width-clear border-gray">
                </li>
                <li>
                    затем после перезагрузки редактора пазлов скопированный блок должен появиться в категории плагина
                </li>
            </ul>
        </p>
    </div>


    [anchor:init_plug_puzzles_order]

    <h5>Puzzles Order</h5>

    <p class="indented">
        Блоки пазлов появляются на панели инструментов в том порядке, который вы определили в файле *init.plug*: 
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;&lt;/block&gt;
        &lt;block type="doSomethingCool"&gt;&lt;/block&gt;
        &lt;!-- &lt;block type="testPuzzle"&gt;&lt;/block&gt; --&gt;
        &lt;block type="anotherPuzzle"&gt;&lt;/block&gt;
&lt;/category&gt;
        </code>
        <img src="files/puzzles/puzzles-plugins-block-order.jpg" style="max-width: 523px"></br>
        Обратите внимание, что закомментированный блок пазла "testPuzzle" не отображается в панели инструментов. 
    </p>


    [anchor:init_plug_text_labels]

    <h5>Текстовые метки</h5>

    <div class="indented">
        <p>
            Вы можете добавить текстовые метки в категорию инструментов с помощью элемента *label*:
        </p>

        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;label text="My Awesome Plugin v1.0"&gt;&lt;/label&gt;
        &lt;label text="Main Puzzles:"&gt;&lt;/label&gt;
        &lt;block type="myPuzzle"&gt;&lt;/block&gt;
        &lt;block type="doSomethingCool"&gt;&lt;/block&gt;
        &lt;label text="Other:"&gt;&lt;/label&gt;
        &lt;block type="anotherPuzzle"&gt;&lt;/block&gt;
&lt;/category&gt;
        </code>

        <img src="files/puzzles/puzzles-plugins-label-elements.jpg" style="max-width: 523px"></br>

        <p class="note">
            *label* элементы не подходят для отображения многострочного текста, т.е. без переносов строк.
        </p>

        <p>
            Элементы *label* также могут быть в некоторой степени стилизованы. Они поддерживают
            атрибут *web-class*, который предназначен для назначения пользовательского CSS-класса
            элементу *label*. Правила CSS для этого класса описаны
            в разделе *init.plug*'s *script*. Этот подход проиллюстрирован
            в следующем примере:
        </p>

        <code>
    &lt;category name="Example Plugin" color="#a52a2a"&gt;
        &lt;label text="Example Plugin v1.0 by Soft8Soft" web-class="example-plugin__label"&gt;&lt;/label&gt;
    &lt;/category&gt;

    &lt;script&gt;
    const styleElem = document.createElement('style');
    styleElem.innerHTML = `
        .example-plugin__label .blocklyFlyoutLabelText {
            fill: #a52a2a;
            font-style: italic;
            font-weight: bold;
            text-decoration: underline;
        }
    `;
    document.head.appendChild(styleElem);
    &lt;/script&gt;
        </code>

        <p>
            А вот результат применения пользовательских настроек CSS:
        </p>
        <img src="files/puzzles/puzzles-plugins-label-elements-styled.png" class="width-clear">

        <p class="note">
            При выборе имени CSS-класса для атрибута *web-class*
            рекомендуется учитывать особенную CSS-подстановку, например,
            использовать префикс, уникальный для вашего плагина пазлов, т.е. в
            примере выше это "example-plugin" часть класса
            "example-plugin__label". Таким образом, вы с меньшей вероятностью случайно
            нарушите какие-либо классы CSS, уже используемые на странице.
        </p>
    </div>


    [anchor:init_plug_separator_elements]

    <h5>Разделители</h5>

    <p class="indented">
        Разделители можно использовать для изменения расстояния между блоками пазла. Вы
        можете добавить разделители в категорию инструментов с помощью элемента *sep*. Атрибут
        *gap* задает ширину расстояния в пикселях. По умолчанию расстояние
        между блоками (если не используется *sep*) равно 24 пикселям.
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;&lt;/block&gt;
        &lt;sep gap="0"&gt;&lt;/sep&gt;
        &lt;block type="doSomethingCool"&gt;&lt;/block&gt;
        &lt;sep gap="80"&gt;&lt;/sep&gt;
        &lt;block type="anotherPuzzle"&gt;&lt;/block&gt;
&lt;/category&gt;
        </code>
        <img src="files/puzzles/puzzles-plugins-sep-elements.jpg" style="max-width: 523px"></br>
    </p>


    [anchor:init_plug_available_puzzles_init]

    <h5>Блоки пазла, доступные на вкладке "init"</h5>

    <p class="indented">
        По умолчанию блоки пазла доступны только на вкладках *main* и на
        созданных пользователем, но не на *init*. Это связано с тем, что код, генерируемый
        вкладкой *init*, выполняется до загрузки и полной инициализации
        приложения Verge3D. Это означает, что пазлы, предназначенные для работы
        с 3d-сценой, 3d-объектами, материалами и т.д., не подходят для использования
        внутри *init* и могут вызвать сбой приложения. Однако пазлы,
        которые не требуют наличия 3d-сцены (например, те, которые предварительно
        загружают ресурсы или настраивают пользовательский интерфейс) не должны иметь
        таких проблем и могут быть разрешены в *init*.<br/><br/>

        Для того чтобы пазл появился на панели инструментов вкладки *init*,
        вам необходимо установить для атрибута *allow-init* значение *true* в элементе *block*
        пазлов (это также работает с элементами *label* и *sep*):
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;label text="My Awesome Plugin v1.0" allow-init="true"&gt;&lt;/label&gt;
        &lt;label text="Main Puzzles:"&gt;&lt;/label&gt;
        &lt;block type="myPuzzle" allow-init="true"&gt;&lt;/block&gt;
        &lt;block type="doSomethingCool"&gt;&lt;/block&gt;
        &lt;label text="Other:"&gt;&lt;/label&gt;
        &lt;block type="anotherPuzzle"&gt;&lt;/block&gt;
&lt;/category&gt;
        </code>
        <img src="files/puzzles/puzzles-plugins-allow-init.jpg" style="max-width: 523px"></br>
        Обратите внимание, что элементы *block* и *label* без *allow-init* не отображаются
        на панели инструментов.
    </p>


    [anchor:init_plug_default_input_field_values]

    <h5>Значения ввода и полей по умолчанию</h5>

    <p class="indented">
        Если блок пазла имеет входы для блока (слоты для подключения других
        блоков пазла) и/или поля ввода (неблочные элементы пользовательского
        интерфейса, такие как селекторы, галочки, текстовые поля и т.д.), то вы можете
        указать их блоки-заполнители и / или значения по умолчанию. Эта функция
        служит двум целям: она даёт пользователям подсказку о том, что
        можно вставить во входной слот, а также делает использование
        пазла немного более удобным.<br/><br/>

        Допустим, у вашего блока пазла есть вход с именем "myNumber".
        Вот как вы можете добавить блок-заполнитель типа *math_number*
        подключенный к этому слоту:
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;
            &lt;value name="myNumber"&gt;
                &lt;block type="math_number"&gt;&lt;/block&gt;
            &lt;/value&gt;
        &lt;/block&gt;
&lt;/category&gt;
        </code>
        А вот как это будет выглядеть:<br/>
        <img src="files/puzzles/puzzles-plugins-default-value-input.jpg" style="max-width: 523px"><br/><br/>

        Блок-заполнитель, вставленный во входной слот, также может быть *shadow*
        блоком. Блоки *Shadow* в основном такие же, как и обычные блоки,
        за исключением того, что они автоматически заменяются блоком, который вы
        вставляете в соответствующий входной слот, и они автоматически
        появляются обратно, когда вы удаляете этот блок из слота. Это делает
        блоки *shadow* немного проще в использовании, чем обычные
        блоки-заполнители.<br/><br/>

        Блоки *Shadow* определяются почти так же, как и обычные
        блоки-заполнители, с той лишь разницей, что элемент *block* заменяется
        аналогичным элементом *shadow*:
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;
            &lt;value name="myNumber"&gt;
                &lt;shadow type="math_number"&gt;&lt;/shadow&gt;
            &lt;/value&gt;
        &lt;/block&gt;
&lt;/category&gt;
        </code>
        И это будет выглядеть следующим образом:<br/>
        <img src="files/puzzles/puzzles-plugins-default-value-input-shadow.jpg" style="max-width: 523px"><br/><br/>

        Блоки пазла могут иметь входные данные команд, которые обычно заключают в себе
        серию дочерних блоков пазла. Предположим, что в вашем блоке пазла
        есть ввод команд под названием "myStatement". Затем вы можете добавить
        к этому входу пару блоков-заполнителей следующим образом:
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;
            &lt;statement name="myStatement"&gt;
                &lt;block type="addHTMLElement"&gt;
                    &lt;next&gt;
                        &lt;block type="setHTMLElemAttribute"&gt;&lt;/block&gt;
                    &lt;/next&gt;
                &lt;/block&gt;
            &lt;/statement&gt;
        &lt;/block&gt;
&lt;/category&gt;
        </code>
        Используемый здесь элемент *statement* ссылается на вход "myStatement" через
        атрибут *name* attribute. Кроме того, в него добавлены некоторые
        блоки-заполнители. Также здесь используется элемент *next* для цепочки
        блоков-заполнителей. Результат этой настройки показан ниже:<br/>
        <img src="files/puzzles/puzzles-plugins-default-value-statement.jpg" style="max-width: 735px"><br/><br/>

        Если в вашем блоке пазле есть поле для галочки с именем "myCheckbox",
        то вы можете задать его состояние по умолчанию (*true* - включен,
        *false* - выключен) следующим образом:
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;
            &lt;field name="myCheckbox"&gt;true&lt;/field&gt;
        &lt;/block&gt;
&lt;/category&gt;
        </code>
        And here's the result:<br/>
        <img src="files/puzzles/puzzles-plugins-default-dummy-input.jpg" style="max-width: 523px"><br/><br/>

        <span id="default_input_values_compound"></span>
        Используя блоки-заполнители и значения полей по умолчанию, вы
        можете создавать сложные составные пазлы аналогичные тем, которые можно добавить в
        <a href="manual/ru/puzzles/Library.html#using_entries">the Puzzles Library</a>:
        <img src="files/puzzles/puzzles-plugins-compound-puzzle.jpg" style="max-width: 600px"><br/>

        Код в *init.plug* для сложного пазла на картинке выше
        может выглядеть следующим образом:
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;

            &lt;statement name="STATEMENT_0"&gt;
                &lt;block type="whenClicked"&gt;
                    &lt;value name="VALUE"&gt;
                        &lt;block type="objectList"&gt;
                            &lt;field name="FIELDNAME"&gt;Cube&lt;/field&gt;
                        &lt;/block&gt;
                    &lt;/value&gt;
                &lt;/block&gt;
            &lt;/statement&gt;

            &lt;statement name="STATEMENT_1"&gt;
                &lt;block type="loadScene"&gt;
                    &lt;value name="URL"&gt;
                        &lt;block type="text"&gt;
                            &lt;field name="TEXT"&gt;my_scene.gltf&lt;/field&gt;
                        &lt;/block&gt;
                    &lt;/value&gt;
                &lt;/block&gt;
            &lt;/statement&gt;

            &lt;statement name="STATEMENT_2"&gt;
                &lt;block type="show"&gt;
                    &lt;value name="VALUE"&gt;
                        &lt;block type="objectList"&gt;
                            &lt;field name="FIELDNAME"&gt;something&lt;/field&gt;
                        &lt;/block&gt;
                    &lt;/value&gt;
                &lt;/block&gt;
            &lt;/statement&gt;

        &lt;/block&gt;
&lt;/category&gt;
        </code>

        <div class="indented">
            <p class="note">
                Проверьте параметр контекстного меню 
                <a href="manual/ru/puzzles/Plugins.html#puzzle-xml-tree">"Print Puzzle XML Tree".</a>
                Это поможет найти XML структуру (конфигурацию
                входов и полей) интересующего вас блока пазла.
            </p>
        </div>
    </p>


    [anchor:init_plug_toolbox_subcategories]

    <h5>Подкатегории панели интрументов</h5>

    <p class="indented">
        Категория в панели инструментов редактора может иметь подкатегории, которые,
        в свою очередь, также могут иметь подкатегории, и так далее... Эта функция
        полезна, если вы хотите организовать пазлы вашего плагина
        в древовидную структуру.<br/><br/>

        Этого можно достичь с помощью встроенного элемента *category*:
        <code>
&lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;&lt;/block&gt;
        &lt;category name="1" color="red"&gt;
            &lt;category name="1.1" color="silver"&gt;
                &lt;block type="anotherPuzzle"&gt;&lt;/block&gt;
            &lt;/category&gt;
        &lt;/category&gt;
        &lt;category name="2" color="blue"&gt;
            &lt;block type="doSomethingCool"&gt;&lt;/block&gt;
        &lt;/category&gt;
&lt;/category&gt;
        </code>
        <img src="files/puzzles/puzzles-plugins-subcategories.jpg" style="max-width: 523px"><br/>
        Любая *category* может содержать одновременно элемент *category* и *block*
        (хотя это не обязательно). Таким образом, она действует как
        родитель для подкатегорий и также предоставляет выбор блоков пазла.
    </p>


    [anchor:init_plug_script]

    <h4>Скрипт</h4>

    <p>
        Элемент <b>&lt;script&gt;</b> является необязательной частью *init.plug*. Его
        можно использовать для добавления кода инициализации для ваших пазлов. Иногда
        вам может потребоваться выполнить тяжелые вычисления и кэшировать некоторые данные,
        прежде чем можно будет использовать какой-либо из ваших пазлов, вот где на помощь приходит
        <b>&lt;script&gt;</b>
    </p>

    <p>
        Если вы определите функцию *code()* внутри <b>&lt;script&gt;</b> она будет использоваться
        для генерации кода, который выполняется один раз перед любым пазлом. Функция
        *code()* должна возвращать строку, содержащую код javascript.

        <code>
    &lt;script&gt;
    function code() {
        // this line will be executed before any puzzles
        return `console.log('Powered by My Awesome Plugin!');`;
    }
    &lt;/script&gt;
        </code>
    </p>

    <p class="note">
        Код инициализации, возвращаемый функцией *code()*, добавляется в сгенерированный файл
        файл логики только в том случае, если пазлы плагина действительно используются
        в приложении (добавлены на рабочее пространство и не отключены).
    </p>


    [anchor:block_file_format]

    <h3>Формат файла .block</h3>

    <p>
        Файлы плагина с расширением <b>.block</b> используются для описания отдельных
        блоков пазла, а именно: как может выглядеть блок и какой код
        он должен генерировать при добавлении в рабочую область. Плагин может вообще
        не иметь файлов <b>.block</b>. Это может быть полезно, если вы хотите создать
        панель инструментов только с <a href="manual/ru/puzzles/Plugins.html#available_puzzles_stock">stock</a>
        блоками пазла (даже включая <a href="manual/ru/puzzles/Plugins.html#default_input_values_compound">более сложные настройки блоков</a>).<br/><br/>

        Имя файла <b>.block</b> используется для указания того, какие блоки пазла
        должны быть <a href="manual/ru/puzzles/Plugins.html#available_puzzles_plugin">включены в категорию инструментов плагина</a>.
    </p>

    <p>
        Вот минимальный пример файла <b>.block</b>:
        <code>
&lt;template color="green"&gt;
        &lt;dummy&gt;
            &lt;label&gt;myPuzzle&lt;/label&gt;
        &lt;/dummy&gt;
&lt;/template&gt;

&lt;script&gt;
    function code(block) {
        return `console.log('This is my first puzzle!');`;
    }
&lt;/script&gt;
        </code>
        Здесь у нас есть элемент <b>&lt;template&gt;</b>, который определяет внешний вид
        блока пазла. А также есть элемент <b>&lt;script&gt;</b>, внутри которого
        находится функция *code()*. Функция *code()* возвращает строку,
        содержащую код, который будет сгенерирован на месте этого
        пазла.<br/><br/>

        Итак, исходя из приведенного выше примера, мы можем полагать, что наш
        простой блок пазла будет зеленого цвета и будет иметь текстовую метку"myPuzzle":<br/>
        <img src="files/puzzles/puzzles-plugins-block-minimal-appearance.jpg" style="max-width: 523px"><br/><br/>

        И если добавить его в рабочую область, он должен вывести следующее сообщение
        в консоль браузера:<br/>
        <img src="files/puzzles/puzzles-plugins-block-minimal-console.jpg" style="max-width: 523px"><br/>
    </p>


    [anchor:block_file_template]

    <h4>Шаблон блока</h4>

    <p>
        Внешний вид блока пазла можно задать двумя способами: через
        <b>&lt;template&gt;</b> XML элемент и через функцию *template()*. Первый
        вариант более прост и удобен в использовании. Например, вот как может
        выглядеть <b>&lt;template&gt;</b> типичного пазла:
    </p>

    <code>
&lt;template
        color="green"
        inline="true"
        output="Dictionary"
        tooltip="This is my first puzzle!"
        help="https://soft8soft.com"
&gt;
        &lt;dummy name="myDummyInput"&gt;
            &lt;label&gt;enable&lt;/label&gt;
            &lt;checkbox name="myCheckbox"&gt;true&lt;/checkbox&gt;
        &lt;/dummy&gt;

        &lt;value name="myValueInput"&gt;
            &lt;label&gt;input value&lt;/label&gt;
        &lt;/value&gt;
&lt;/template&gt;

&lt;script&gt;
    function code(block) {
        return `console.log('This is my first puzzle!');`;
    }
&lt;/script&gt;
    </code>

    <p>
        Другой подход заключается в использовании функции *template()*. Это функция,
        которую вы можете определить внутри элемента <b>&lt;script&gt;</b>. Её также
        можно использовать для настройки внешнего вида пазла, но на этот раз
        через <a href="https://developers.google.com/blockly/reference/overview">Blockly JavaScript API</a>,
        а не через элементы и атрибуты XML. Он получает параметр *block*,
        который является копией <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg">Blockly.BlockSvg</a>.<br/><br/>

        Тот же блок, что и в примере выше, можно переписать с помощью функции
        *template()* следующим образом:
    </p>

    <code>
&lt;script&gt;
function template(block) {
        block.setColor('green');
        block.setInputsInline(true);
        block.setOutput(true, 'Dictionary');
        block.setTooltip('This is a test puzzle!');
        block.setHelpUrl('https://soft8soft.com');

        block.appendDummyInput('myDummyInput')
        .appendField('enable')
        .appendField(new Blockly.FieldCheckbox(true), 'myCheckbox');

        block.appendValueInput('myValueInput')
        .appendField('input value');
}

function code(block) {
        return `console.log('This is my first puzzle!');`;
}
&lt;/script&gt;
    </code>

    <p>
        Этот подход более гибкий, но требует знания
        соответствующих APIs. Он особенно полезен, если вам нужно выполнить какую-то
        нетривиальную настройку, которую невозможно осуществить с помощью элемента <b>&lt;template&gt;</b>.
        Более того, вы можете использовать и <b>&lt;template&gt;</b> и *template()*.
        одновременно.
    </p>

    <p class="note">
        В этом разделе приведены примеры как для <b>&lt;template&gt;</b> (*XML*)
        так и для *template()* (*JS*).
    </p>

    <p class="note">
        Обратите внимание, что этот раздел - лишь краткий обзор того, как
        создать пользовательский блок пазла. Для получения более подробной информации об общей
        настройке, ознакомьтесь с документацией Google Blockly о
        <a href="https://developers.google.com/blockly/guides/create-custom-blocks/overview">настраиваемых блоках</a>
        и <a href="https://developers.google.com/blockly/guides/create-custom-blocks/fields/overview">полях</a>.
    </p>


    [anchor:block_file_template_block_color]

    <h5>Цвет блока</h5>

    <div class="indented">

        <p>Вы можете установить цвет блока, чтобы придать пазлам особый вид:</p>
        <img src="files/puzzles/puzzles-plugins-template-color.png" class="width-clear border-gray">

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                Может быть задан с помощью атрибута *color*:
                <code>
    &lt;template color="green"&gt;&lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                Можно настроить с помощью <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setColour">block.setColor</a>:
                <code>
    &lt;script&gt;
    function template(block) {
        block.setColor('green');
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>

        <p>
            Цвета должны быть в одном из описанных здесь форматов:
            <a href="manual/ru/puzzles/Plugins.html#color_formats">цветовой формат</a>.
        </p>
    </div>


    [anchor:block_file_template_block_tooltip]

    <h5>Всплывающая подсказка блока</h5>

    <div class="indented">
        <p>
            Можно добавить всплывающую подсказку, которая появляется при наведении курсора на блок.
            Подсказка полезна для предоставления пользователю простого описания того,
            для чего предназначен пазл, как он работает, какие есть советы
            по использованию и т.д...
        </p>

        <img src="files/puzzles/puzzles-plugins-template-tooltip.png" class="width-clear border-gray">

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                Можно установить с помощью атрибута *tooltip*:
                <code>
    &lt;template tooltip="This is my first puzzle!"&gt;&lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                Можно настроить с помощью <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setTooltip">block.setTooltip</a>:
                <code>
    &lt;script&gt;
    function template(block) {
        block.setTooltip('This is my first puzzle!');
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>
    </div>


    [anchor:block_file_template_block_help_url]

    <h5>Блок URL справки</h5>

    <div class="indented">

        <p>
            Если <a href="manual/ru/puzzles/Plugins.html#block_file_template_block_tooltip">tooltip</a>
            недостаточно для описания вашего пазла, вы также можете добавить ссылку
            на сайт с более подробной документацией. Эта ссылка будет использоваться
            для пункта *Help* в контекстном меню пазла (щелкните правой кнопкой мыши на пазле):
        </p>

        <img src="files/puzzles/puzzles-plugins-template-helpurl.png" class="width-clear border-gray">

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                Может быть задан с помощью атрибута *help*:
                <code>
    &lt;template help="https://www.soft8soft.com/"&gt;&lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                Можно настроить с помощью <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setHelpUrl">block.setHelpUrl</a>:
                <code>
    &lt;script&gt;
    function template(block) {
        block.setHelpUrl('https://www.soft8soft.com/');
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>
    </div>


    [anchor:block_file_template_block_adding_inputs]

    <h5>Добавление входа</h5>

    <div class="indented">
        <p>
            Блоки пазла могут содержать слоты ввода для подключения других блоков.
            Также они могут содержать неблочные элементы пользовательского интерфейса,
            такие как галочки или текстовые поля. Существует 3 различных типа входов:
            *value inputs*,*statement inputs* и *dummy inputs*.

            <ul>
                <li id="adding_inputs_value">
                    *value inputs* - входные слоты, которые можно использовать для
                    подключения блоков, имеющих обратное значение (выходное соединение),
                    например, вход с какими-либо математическими блоками. Внутри математического
                    блока вычисляют и получают определенное значение, к которому может
                    получить доступ родительский блок (блок, содержащий входной слот).
                </li>
                <li id="adding_inputs_statement">
                    *statement inputs* - это входы, которые могут содержать группу блоков,
                    представляющих серию последовательных действий, например,
                    пазл <a href="manual/ru/puzzles/Logic.html#if_else">if-else</a>
                    имеет именно такой тип ввода для группы блоков пазла
                    по условиям "true" или "false".
                </li>
                <li id="adding_inputs_dummy">
                    *dummy inputs* - это входы, подходящие только для добавления неблочных
                    элементов пользовательского интерфейса, таких как галочки, текстовые поля, изображения и т.д..
                    Смотрите <a href="manual/ru/puzzles/Plugins.html#block_file_template_adding_fields">добавление полей</a>
                    для получения дополнительной информации.
                </li>
            </ul>
        </p>

        <p>
            Разницу между этими типами входов можно увидеть на 
            рисунке ниже:
        </p>

        <img src="files/puzzles/puzzles-plugins-template-input-types.png" class="width-clear border-gray">

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                Используйте элементы <b>&lt;value&gt;</b>, <b>&lt;statement&gt;</b> и
                <b>&lt;dummy&gt;</b> для добавления входов. Входы *Value* и *statement*
                должны иметь имя (для этого используйте их атрибут *name*). Входам
                *Dummy* обычно не нужны имена, они являются просто областями для полей.
                <a href="manual/ru/puzzles/Plugins.html#block_file_template_adding_fields">fields</a>.
                <code>
    &lt;template&gt;
        &lt;value name="myInput"&gt;&lt;/value&gt;

        &lt;statement name="myStatement"&gt;&lt;/statement&gt;

        &lt;dummy&gt;
            &lt;checkbox name="myCheckbox"&gt;true&lt;/checkbox&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                Для добавления входов используйте способы
                <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#appendValueInput">block.appendValueInput</a>,
                <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#appendStatementInput">block.appendStatementInput</a>
                и <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#appendDummyInput">block.appendDummyInput</a>.
                Входы *Value* и *statement* должны иметь имя
                (через атрибут *name*). Входы *Dummy* обычно не нуждаются в именах,
                они являются просто контейнерами для
                <a href="manual/ru/puzzles/Plugins.html#block_file_template_adding_fields">fields</a>.
                <code>
    &lt;script&gt;
    function template(block) {
        block.appendValueInput('myValue');

        block.appendStatementInput('myStatement');

        block.appendDummyInput()
        .appendField(new Blockly.FieldCheckbox(true), 'myCheckbox');
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>
    </div>


    [anchor:block_file_template_arrangement_inputs]

    <h5>Расположение входов</h5>

    <div class="indented">
        <p>
            Входы блоков могут быть расположены вертикально (по умолчанию)
            или горизонтально.
        </p>

        <img src="files/puzzles/puzzles-plugins-inputs-inline.png" class="width-clear border-gray">

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                Может быть задан с помощью атрибута *inline*, который может быть либо
                *true* либо *false*. *false*для вертикального расположения, а 
                *true* - для горизонтального.
                <code>
    &lt;template inline="true"&gt;&lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                Может быть установлен через <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setInputsInline">block.setInputsInline</a>
                метод. Метод получает параметр, который может быть либо
                *true* либо *false*. *false* - для вертикального расположения и
                *true* - для горизонтального варианта.
                <code>
    &lt;script&gt;
    function template(block) {
        block.setInputsInline(true);
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>
    </div>


    [anchor:block_file_template_adding_fields]

    <h5>Добавление полей</h5>

    <div class="indented">
        <p>
            Вы можете добавить такие элементы пользовательского интерфейса, как
            текстовые метки, галочки, выпадающие списки, текстовые вводы и многое другое в ваших пазлах.
            Эти элементы пользовательского интерфейса называются "поля". Их можно добавлять к входам
            любого типа, но если вы не хотите дополнительно создавать слоты ввода для блоков пазла,
            вам следует придерживаться следующих правил использования 
            <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy inputs</a>.
        </p>

        <p>
            Есть несколько особенностей, которые объединяют все поля:
            <ul>
                <li>
                    Возможность указать дополнительное параметр *name*, который часто
                    используется для ссылки на поле в функции
                    <a href="manual/ru/puzzles/Plugins.html#block_file_code">code()</a>
                    для получения значения поля.
                </li>
                <li>
                    Возможность предоставить дополнительное значение по умолчанию.
                    Тем не менее, значение по умолчанию, указанное в *init.plug*'s
                    <a href="manual/ru/puzzles/Plugins.html#init_plug_default_input_field_values">category</a>,
                    всегда имеет более высокий приоритет, чем значение, указанное
                    в шаблоне пазла.
                </li>
            </ul>
        </p>

        <p>
            Давайте посмотрим, как добавить различные поля в пазл.
        </p>
    </div>

    <ul>
        <li>
            <p>label - нередактируемое текстовое поле</p>

            <img src="files/puzzles/puzzles-plugins-field-text-label.png" class="width-clear border-gray">

            <v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>
                    Может быть добавлен с помощью элемента <b>&lt;label&gt;</b>, вложенного в элемент
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">заглушка</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">значение</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">оператор</a>.
                    <code>
    &lt;template&gt;
        &lt;dummy&gt;
            &lt;label&gt;a text label&lt;/label&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;
                    </code>
                </div>

                <label>JS</label>
                <div>
                    Может быть добавлен через метод 
                    <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a>
                    и <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldLabel">Blockly.FieldLabel</a>
                    к <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">заглушка</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">значение</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">оператор</a>.
                    <code>
    &lt;script&gt;
    function template(block) {
        block.appendDummyInput()
        .appendField(new Blockly.FieldLabel('a text label'));
    }
    &lt;/script&gt;
                    </code>
                </div>
            </v3d-tabs>
        </li>

        <li>
            <p>text - редактируемое текстовое поле</p>

            <img src="files/puzzles/puzzles-plugins-field-text.png" class="width-clear border-gray">

            <v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>
                    Может быть добавлен с помощью элемента <b>&lt;text&gt;</b> вложенного в элемент
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">заглушка</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">значение</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">оператор</a>.
                    <code>
    &lt;template&gt;
        &lt;dummy&gt;
            &lt;text name="myText"&gt;default text&lt;/text&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;
                    </code>
                </div>

                <label>JS</label>
                <div>
                    Может быть добавлен через метод 
                    <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a>
                    и <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldTextInput">Blockly.FieldTextInput</a>
                    к <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">заглушка</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">значение</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">оператор</a>.
                    <code>
    &lt;script&gt;
    function template(block) {
        block.appendDummyInput()
        .appendField(new Blockly.FieldTextInput('default text'), 'myText');
    }
    &lt;/script&gt;
                    </code>
                </div>
            </v3d-tabs>
        </li>

        <li>
            <p>multiline text - редактируемое многострочное текстовое поле</p>

            <img src="files/puzzles/puzzles-plugins-field-text-multiline.png" class="width-clear border-gray">

            <v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>
                    Может быть добавлен с помощью элемента <b>&lt;multiline&gt;</b> вложенного в элемент
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">заглушка</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">значение</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">оператор</a>.
                    <code>
    &lt;template&gt;
        &lt;dummy&gt;
            &lt;multiline name="myTextMultiline"&gt;This is a \n multiline \n   text&lt;/multiline&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;
                    </code>
                </div>

                <label>JS</label>
                <div>
                    Может быть добавлен через метод
                    <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a>
                    м <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldMultilineInput">Blockly.FieldMultilineInput</a>
                    к <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">заглушка</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">значение</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">оператор</a>.
                    <code>
    &lt;script&gt;
    function template(block) {
        block.appendDummyInput()
        .appendField(new Blockly.FieldMultilineInput('This is a \n multiline \n   text'), 'myTextMultiline');
    }
    &lt;/script&gt;
                    </code>
                </div>
            </v3d-tabs>
        </li>

        <li>
            <p>number - редактируемое поле для числовых значений</p>

            <img src="files/puzzles/puzzles-plugins-field-number.png" class="width-clear border-gray">

            <v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>
                    Может быть добавлено через <b>&lt;number&gt;</b> элемент, вложенный внутрь
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    <code>
    &lt;template&gt;
        &lt;dummy&gt;
            &lt;number name="myNumber"&gt;3&lt;/number&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;
                    </code>
                </div>

                <label>JS</label>
                <div>
                    Может быть добавлено через <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a>
                    метод и <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldNumber">Blockly.FieldNumber</a>
                    к <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    <code>
    &lt;script&gt;
    function template(block) {
        block.appendDummyInput()
        .appendField(new Blockly.FieldNumber(3), 'myNumber');
    }
    &lt;/script&gt;
                    </code>
                </div>
            </v3d-tabs>
        </li>

        <li>
            <p>angle - редактируемое поле для числовых значений, представляющих углы (в градусах)</p>

            <img src="files/puzzles/puzzles-plugins-field-number-angle.png" class="width-clear border-gray">

            <v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>
                    Может быть добавлено через <b>&lt;angle&gt;</b> элемент, вложенный внутрь
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    <code>
    &lt;template&gt;
        &lt;dummy&gt;
            &lt;angle name="myAngle"&gt;15&lt;/angle&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;
                    </code>
                </div>

                <label>JS</label>
                <div>
                    Может быть добавлено через <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a>
                    метод и <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldAngle">Blockly.FieldAngle</a>
                    к <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    <code>
    &lt;script&gt;
    function template(block) {
        block.appendDummyInput()
        .appendField(new Blockly.FieldAngle(15), 'myAngle');
    }
    &lt;/script&gt;
                    </code>
                </div>
            </v3d-tabs>
        </li>

        <li id="block_file_template_adding_fields_checkbox">
            <p>checkbox - типичное поле с галочкой</p>

            <img src="files/puzzles/puzzles-plugins-field-checkbox.png" class="width-clear border-gray">

            <v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>
                    Может быть добавлено через <b>&lt;checkbox&gt;</b> элемент, вложенный внутрь
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    Состояние флажка по умолчанию должно быть установлено в *true* или *false*.
                    <code>
    &lt;template&gt;
        &lt;dummy&gt;
            &lt;checkbox name="myCheckbox"&gt;true&lt;/checkbox&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;
                    </code>
                </div>

                <label>JS</label>
                <div>
                    Может быть добавлено через <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a>
                    метод и <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldCheckbox">Blockly.FieldCheckbox</a>
                    к <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    Состояние флажка по умолчанию передается в качестве параметра в *Blockly.FieldCheckbox* и может быть либо *true*, либо *false*.
                    <code>
    &lt;script&gt;
    function template(block) {
        block.appendDummyInput()
        .appendField(new Blockly.FieldCheckbox(true), 'myCheckbox');
    }
    &lt;/script&gt;
                    </code>
                </div>
            </v3d-tabs>
        </li>

        <li id="block_file_template_adding_fields_dropdown">
            <p>dropdown - список значений для выбора</p>

            <img src="files/puzzles/puzzles-plugins-field-dropdown.png" class="width-clear border-gray">

            <v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>
                    <p>
                        Может быть добавлено через <b>&lt;dropdown&gt;</b> элемент, вложенный внутрь
                        <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                        <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                        и <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    </p>
                    <p>
                        Для создания списка опций добавьте элементы <b>&lt;option&gt;</b>
                        внутри <b>&lt;dropdown&gt;</b>. У всех элементов
                        <b>&lt;option&gt;</b> атрибут *name* должен быть установлен на
                        уникальный идентификатор (что-то, что будет более подходящим
                        wдля использования в коде, например COLOR_GREEN).
                        Текст, содержащийся между начальным и конечным тегами
                        <b>&lt;option&gt;</b>, используется в качестве метки, 
                        отображаемой в выпадающем виджете для данной опции.
                    </p>
                    <p>
                        Выбранный по умолчанию параметр можно установить, задав атрибуту
                        *default* параметра значение *true*.
                    </p>
                    <code>
    &lt;template&gt;
        &lt;dummy&gt;
            &lt;dropdown name="myDropdown"&gt;
                &lt;option name="COLOR_GREEN"&gt;green&lt;/option&gt;
                &lt;option name="COLOR_YELLOW" default="true"&gt;yellow&lt;/option&gt;
                &lt;option name="COLOR_RED"&gt;red&lt;/option&gt;
            &lt;/dropdown&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;
                    </code>
                </div>

                <label>JS</label>
                <div>
                    <p>
                        Может быть добавлено через <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a>
                        метод и <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldDropdown">Blockly.FieldDropdown</a>
                        к <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                        <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                        или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    </p>
                    <p>
                        Первым параметром *Blockly.FieldDropdown* может быть массив доступных опций.
                        Каждая опция, в свою очередь, также является массивом из 2 элементов:
                        текст для отображения в UI интерфейсе in the UI (человеческий дружественный текст,
                        обозначающий, о чем данная опция) и уникальный идентификатор (то, что было бы
                        более подходящим для использования в коде, например, 
                        code, e.g. COLOR_GREEN).
                    </p>
                    <p>
                        Выбранную по умолчанию опцию можно установить, выбрав метод
                        <a href="https://developers.google.com/blockly/reference/js/Blockly.Field#setValue">setValue</a>.
                        TЧтобы указать, какая опция должна быть выбрана
                        по умолчанию, просто введите уникальный идентификатор опции в качестве
                        параметра в *setValue*.
                    </p>
                    <code>
    &lt;script&gt;
    function template(block) {
        let field = new Blockly.FieldDropdown([
            // [ displayed text, option name ]
            ['green', 'COLOR_GREEN'],
            ['yellow', 'COLOR_YELLOW'],
            ['red', 'COLOR_RED'],
        ]);

        // setting default option
        field.setValue('COLOR_YELLOW');

        block.appendDummyInput()
        .appendField(field, 'myDropdown');
    }
    &lt;/script&gt;
                    </code>
                </div>
            </v3d-tabs>
        </li>

        <li>
            <p>color picker - виджет для выбора цвета</p>

            <img src="files/puzzles/puzzles-plugins-field-color.png" class="width-clear border-gray">

            <v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>
                    Может быть добавлено через <b>&lt;color&gt;</b> элемент, вложенный внутрь
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    <code>
    &lt;template&gt;
        &lt;dummy&gt;
            &lt;color name="myColor"&gt;#350af5&lt;/color&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;
                    </code>
                </div>

                <label>JS</label>
                <div>
                    Может быть добавлено через <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a>
                    метод и <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldColour">Blockly.FieldColor</a>
                    к <a href="manual/ru/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>,
                    <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value</a>
                    или <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement</a>.
                    <code>
    &lt;script&gt;
    function template(block) {
        block.appendDummyInput()
        .appendField(new Blockly.FieldColor('#350af5'), 'myColor');
    }
    &lt;/script&gt;
                    </code>
                </div>
            </v3d-tabs>
        </li>
    </ul>


    [anchor:block_file_template_field_alignment]

    <h5>Выравнивание полей</h5>

    <div class="indented">
        <p>

            Элементы поля в блоке пазла всегда принадлежат определенному слоту входа.
            Будь то одно поле или несколько полей на вход, они всегда отображаются
            в соответствии с определенным расположением. Одно, что можно изменить - это
            расположение полей внутри входа, в частности, с какой стороны они
            выравниваются. Их можно выровнять слева (по умолчанию),
            справа и по центру.
        </p>

        <img src="files/puzzles/puzzles-plugins-field-alignment.png" class="width-clear border-gray">

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                Чтобы изменить выравнивание поля для определенного ввода, используйте атрибут *align*
                у соответствующего <a href="manual/ru/puzzles/Plugins.html#block_file_template_block_adding_inputs">input element</a>.
                Действующими значениями этого атрибута являются: *left*, *center* и *right*.
                <code>
    &lt;template&gt;
        &lt;dummy align="left"&gt;&lt;/dummy&gt;
        &lt;value align="center" name="myValueInput"&gt;&lt;/value&gt;
        &lt;statement align="right" name="myStatementInput"&gt;&lt;/statement&gt;
    &lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                Чтобы изменить выравнивание поля для определенного ввода, используйте метод
                <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#setAlign">setAlign</a>.
                Его первый параметр должен быть  *Blockly.ALIGN_LEFT*,
                *Blockly.ALIGN_CENTER* или *Blockly.ALIGN_RIGHT*.
                <code>
    &lt;script&gt;
    function template(block) {
        block.appendDummyInput()
        .setAlign(Blockly.ALIGN_LEFT);

        block.appendValueInput('myValueInput')
        .setAlign(Blockly.ALIGN_CENTER);

        block.appendStatementInput('myStatementInput')
        .setAlign(Blockly.ALIGN_RIGHT);
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>
    </div>


    [anchor:block_file_template_block_connections]

    <h5>Блочные соединения</h5>

    <div class="indented">
        <p>
            Puzzle blocks can have input, statement and output connections.
            Input connections are added automatically for each input slot
            created and serve the purpose of plugging in child blocks. See more
            information on creating inputs here:
            <a href="manual/ru/puzzles/Plugins.html#block_file_template_block_adding_inputs">adding inputs</a>.
            Statement (previous and next) and output connections are used for
            connecting blocks to a parent block or sibling blocks.
        </p>
        <p>
            *Previous* and *next* add connections at the top and at the bottom
            of a puzzle block respectively, so the block can be connected from
            below/above to other blocks that have a matching connection.
        </p>
        <p>
            *Output* adds a connection at the left side of a block - this allows
            the block to be plugged into an input slot of a parent block. The
            output connection typically used for puzzle blocks that return a
            value, e.g. the result of some math calculations.
        </p>
        <p>
            By default a puzzle block doesn't have any connections at all. You
            can add a single connection of any type to a puzzle block. You can
            add even 2 statement/output connections to a block, but only the
            following combinations are allowed: *previous* + *next* or
            *next* + *output*.
        </p>

        <img src="files/puzzles/puzzles-plugins-output-connections.png" class="width-clear border-gray">

        <p>
            Here's how all those connections can be added to a block:
        </p>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                The *previous* statement connection can be enabled by setting the
                *prev* attribute to *true*:
                <code>
    &lt;template prev="true"&gt;&lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                The *previous* statement connection can be enabled by calling
                <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setPreviousStatement">block.setPreviousStatement</a>
                with *true* as the first parameter:
                <code>
    &lt;script&gt;
    function template(block) {
        block.setPreviousStatement(true);
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                The *next* statement connection can be enabled by setting the
                *next* attribute to *true*:
                <code>
    &lt;template next="true"&gt;&lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                The *next* statement connection can be enabled by calling
                <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setNextStatement">block.setNextStatement</a>
                with *true* as the first parameter:
                <code>
    &lt;script&gt;
    function template(block) {
        block.setNextStatement(true);
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                The *output* connection can be enabled by setting the *output*
                attribute to an empty string:
                <code>
    &lt;template output=""&gt;&lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                The *output* connection can be enabled by calling
                <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setOutput">block.setOutput</a>
                with *true* as the first parameter:
                <code>
    &lt;script&gt;
    function template(block) {
        block.setOutput(true);
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>
    </div>


    [anchor:block_file_template_input_output_type_checking]

    <h5>Input/Output Type Checking</h5>

    <div class="indented">
        <p>
            By default all puzzle blocks that have suitable inputs/outputs can be
            connected with each other. Yet, that doesn't mean all blocks should
            be compatible. Let's say that we have a puzzle block returning an
            array of coordinates, while some other block has an input that
            expects an animation name. If we try to plug the first block into
            the second one then things might not work as expected. The code
            generated from those puzzles can be invalid and even lead to a crash.
        </p>
        <p>
            Fortunately, there's a way to resolve that situation. Every input
            and output can be assigned a type and only those blocks that have
            matching types can be connected with each other.
        </p>
        <p class="note">
            For general information about output and other connections see
            <a href="manual/ru/puzzles/Plugins.html#block_file_template_block_connections">block connections</a>.
        </p>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                The output type can be specified via the <b>&lt;template&gt;</b>'s
                *output* attribute. The types that a particular input can accept
                are defined by the input's *type* attribute.
                <code>
    &lt;!-- the block's output type is 'String' --&gt;
    &lt;template output="String"&gt;
        &lt;!-- this input accepts only blocks of type 'Number' --&gt;
        &lt;value name="myInput" type="Number"&gt;&lt;/value&gt;
    &lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                The output type can be assigned to a block by calling the
                <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setOutput">block.setOutput</a>
                method while passing *true* as its first and the desired type as
                its second parameter. The types that a particular input can
                accept are set by calling the
                <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#setCheck">setCheck</a>
                method.
                <code>
    &lt;script&gt;
    function template(block) {
        // this input accepts only blocks of type 'Number'
        block.appendValueInput('myInput')
        .setCheck('Number');

        // the block's output type is 'String'
        block.setOutput(true, 'String');
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>

        <p>
            In the example above the block has an input that can only accept
            blocks of the type "Number" or of an unspecified type (if no type
            was set via *setOutput*). The block also has the "String" output
            type, which means that it can be only plugged into an input having
            the "String" or an unspecified type (if no type was set via *setCheck*).
        </p>
        <p>
            Inputs and outputs can also have more than one type:
        </p>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>
                In order to have multiple input/output types fill the
                corresponding *type* and *output* attributes with multiple type
                values separated by space:
                <code>
    &lt;!-- this block's output type is 'String' or 'Animation' --&gt;
    &lt;template output="String Animation"&gt;
        &lt;!-- this input accepts only blocks of type 'Number' or 'Object3D' --&gt;
        &lt;value name="myInput" type="Number Object3D"&gt;&lt;/value&gt;
    &lt;/template&gt;
                </code>
            </div>

            <label>JS</label>
            <div>
                In order to have multiple input/output types provide the array of
                types into *setCheck* and/or *setOutput* .
                <code>
    &lt;script&gt;
    function template(block) {
        // this input accepts only blocks of type 'Number' or 'Object3D'
        block.appendValueInput('myInput')
        .setCheck(['Number', 'Object3D']);

        // this block's output type is 'String' or 'Animation'
        block.setOutput(true, ['String', 'Animation']);
    }
    &lt;/script&gt;
                </code>
            </div>
        </v3d-tabs>

        <p>
            Standard Verge3D puzzles use several certain input/output types, which
            you may borrow for your puzzles as well:
        </p>
        <ul>
            <li>
                for javascript types and built-in objects there are:
                *Number*, *String*, *Boolean*, *Dictionary* (for js objects),
                *Array*, *Promise*
            </li>
            <li>
                for scene entities: *Object3D*, *Material*, *Animation*
            </li>
            <li>
                other types: *Canvas*, *Sound*, *Video*
            </li>
        </ul>
        <p>
            You are not limited with the types described above and it's even
            encouraged to come up with your own input/output types that suit
            your puzzles better.
        </p>
    </div>


    [anchor:block_file_code]

    <h4>Code Function</h4>

    <p>
        The *code()* function is used to provide javascript code that should be
        generated for the puzzle if it's added to a workspace. Generally, this
        is the place where you define the puzzle's logic and where you implement
        most of the puzzle's features.
    </p>

    <p>
        The function is expected to return a string containing js code. The way
        it works is similar to how <a href="manual/ru/puzzles/Plugins.html#init_plug_script">init.plug's code function</a>
        works, except that in this case the code will be added and used as many
        times as how many puzzle blocks are added to a workspace. The *code()*
        function receives a *block* parameter - it's the same instance of
        <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg">Blockly.BlockSvg</a>
        that's used in <a href="manual/ru/puzzles/Plugins.html#block_file_template">template()</a>.
    </p>

    <p>
        Let's look at what you can do with the *code()* function.
    </p>


    [anchor:block_file_code_basic_code_generation]

    <h5>Basic Code Generation</h5>

    <p class="indented">
        The very simple thing that *code()* can do is to return a string with a
        couple of lines of javascript code, which will be added into the
        resulting visual_logic.js file.<br/>

        For example, the following code opens the standard browser alert dialog:
        <code>
    function code(block) {
        return `alert('Test');`;
    }
        </code>

        And here we just return a value of 1:
        <code>
    function code(block) {
        return `1`;
    }
        </code>
        - this example doesn't make much sense unless the block has the output
        connection. In that case the returned value can be accessed from a
        parent block that has this block plugged into one of the inputs.<br/><br/>

        And now for a bit more advanced example:
        <code>
    function code(block) {
        const fun = function() {
            app.scene.traverse(function(obj) {
                obj.material = new v3d.MeshBasicMaterial({
                    color: new v3d.Color(Math.random(), Math.random(), Math.random())
                });
            });
        }
        return `(${fun})();`;
    }
        </code>
        - here all objects get a new material with a randomly generated color.
    </p>


    [anchor:block_file_code_mitigating_code_bloat]

    <h5>Mitigating Code Bloat</h5>

    <p class="indented">
        By default, a puzzle's code is copied into the generated visual_logic.js
        file each time the puzzle is used on a workspace. It's not a problem if
        you have just a couple of lines of code. But if the code is bulky,
        complex and split into several functions that you might want to declare
        only once, then the default approach becomes inefficient and causes the
        resulting visual_logic.js file to bloat.<br/><br/>

        To deal with that you can utilize a special method available inside the
        *code()* function. It is called *Plug.provide()*. Let's demonstrate how
        to use it with the following example:

        <code>
    function code(block) {
        const fun = Plug.provide('myFunction', function(a, b, c) {
            console.log(a, b, c);
        });

        return `${fun}(1, 2, 3);`;
    }
        </code>

        Here we have a function "myFunction" defined via *Plug.provide()*,
        which means that no matter how many times the puzzle is used on a
        workspace, "myFunction" will be copied to visual_logic.js just once. Also,
        the value that is actualy returned from *code()* is just <b>${fun}(1, 2, 3);</b>,
        which is basically the function call <b>"myFunction(1, 2, 3);"</b> that
        will be inserted into visual_logic.js for every such puzzle used on a
        workspace. And this is what we exactly would want from our puzzle,
        because "myFunction" only needs to be declared just once, and after that
        it can be called multiple times.<br/><br/>

        The first parameter in *Plug.provide()* should be a unique function
        identifier. The returned variable *fun* is the name of the provided
        function (it's usually almost the same as the value passed in the first
        parameter, but can be different because the Puzzles Editor needs to
        ensure that the name is valid and there's no collisions with other
        functions/variables used on a workspace). That name (instead of the
        original "myFunction") should be used to call the provided function -
        that is how it's done in the part under the return statement.<br/><br/>
    </p>


    [anchor:block_file_code_inputs_fields]

    <h5>Accessing Inputs and Fields</h5>

    <p class="indented">
        If a puzzle block has <a href="manual/ru/puzzles/Plugins.html#block_file_template_adding_fields">fields</a>
        or <a href="manual/ru/puzzles/Plugins.html#block_file_template_block_adding_inputs">input slots</a>
        defined in the <a href="manual/ru/puzzles/Plugins.html#block_file_template">template()</a> function,
        then you would most likely want them to affect what is generated inside
        the *code()* function. For example, a
        <a href="manual/ru/puzzles/Plugins.html#block_file_template_adding_fields_checkbox">checkbox</a>
        can enable or disable one of your puzzle's features.<br/><br/>

        The API methods used to access <a href="manual/ru/puzzles/Plugins.html#adding_inputs_value">value inputs</a>,
        <a href="manual/ru/puzzles/Plugins.html#adding_inputs_statement">statement inputs</a>
        and <a href="manual/ru/puzzles/Plugins.html#block_file_template_adding_fields">fields</a>
        are namely: <a href="https://developers.google.com/blockly/reference/js/Blockly.Generator#valueToCode">Blockly.JavaScript.valueToCode</a>,
        <a href="https://developers.google.com/blockly/reference/js/Blockly.Generator#statementToCode">Blockly.JavaScript.statementToCode</a>
        and <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#getFieldValue">block.getFieldValue</a>.<br/><br/>

        Let's make a puzzle block that has both inputs and fields. Here's the
        full content of the .block file:
        <code>
    &lt;template color="green"&gt;
        &lt;dummy&gt;
            &lt;label&gt;myPuzzle&lt;/label&gt;
        &lt;/dummy&gt;

        &lt;value name="myValue"&gt;&lt;/value&gt;

        &lt;statement name="myStatement"&gt;&lt;/statement&gt;

        &lt;dummy&gt;
            &lt;checkbox name="myCheckbox"&gt;true&lt;/checkbox&gt;
        &lt;/dummy&gt;
    &lt;/template&gt;

    &lt;script&gt;
    function wrapFn(contents) {
        return `function() {${contents}}`;
    }

    function code(block) {
        const myInput = Blockly.JavaScript.valueToCode(block, 'myValue',
                Blockly.JavaScript.ORDER_NONE) || `''`;

        const myStatement = wrapFn(Blockly.JavaScript.statementToCode(block, 'myStatement'));

        const myCheckbox = block.getFieldValue('myCheckbox') === 'TRUE';

        const fun = Plug.provide('myFunction', function(input, statements, checkbox) {
            console.log('input value:', input);
            statements(); // execute puzzles from the myStatement input
            console.log('checkbox state:', checkbox);
        });
        return `${fun}(${myInput}, ${myStatement}, ${myCheckbox});`;
    }
    &lt;/script&gt;
        </code>
        In this example the block defines a value input called "myValue", a
        statement input "myStatement" and a checkbox field "myCheckbox". We obtain
        their values via the API described above, but before we pass them into
        "myFunction" they undergo some noteworthy changes:

        <code>
    var myInput = Blockly.JavaScript.valueToCode(block, 'myValue', Blockly.JavaScript.ORDER_NONE) || `''`;
        </code>
        - an input slot might have no blocks plugged into it, so we just ensure
        that in such a case we get an empty string by adding the *|| `''`* part
        at the end.

        <code>
    function wrapFn(contents) {
        return `function() {${contents}}`;
    }

    ...

    var myStatement = wrapFn(Blockly.JavaScript.statementToCode(block, 'myStatement'));
        </code>
        - a statement input slot usually contains a group of statements. It is
        convenient to wrap them in a function (see what *wrapFn* does) in order
        to pass that function object as a parameter and then treat it as a
        callback.

        <code>
    var myCheckbox = block.getFieldValue('myCheckbox') === 'TRUE';
        </code>
        - here the checkbox value is just compared against "TRUE" to produce a
        boolean result.<br/><br/>

        In the end, all of the values can be passed into "myFunction" as follows:
        <code>
    return `${fun}(${myInput}, ${myStatement}, ${myCheckbox});`;
        </code>

        So, now you are able to use them however you want:
        <code>
    const fun = Plug.provide('myFunction', function(input, statements, checkbox) {
        console.log('input value:', input);
        statements(); // execute puzzles from the myStatement input
        console.log('checkbox state:', checkbox);
    });
        </code>
    </p>

    [anchor:%TOC_DECLEVEL_HACK]<h1></h1>
    [anchor:%TOC_DECLEVEL_HACK]<h1></h1>

    [anchor:plugin_errors]

    <h2>Plugin and Block Errors</h2>

    <p>
        When developing or using plugins you can experience different errors
        related to a certain puzzle block or even a whole plugin. This section
        describes typical plugin and block errors and how to deal with them.
    </p>

    <p>
        If something goes wrong during loading a plugin or initializing its
        puzzle blocks, then the Puzzles Editor prints a corresponding error
        message in the browser console. Usually, such error looks like one of
        the following:
    </p>

    <p class="code red">
        PluginError(PLUGIN_NAME) ...<br/>
        BlockError(PLUGIN_NAME/BLOCK_NAME) ...<br/>
        Puzzle "PLUGIN_NAME/BLOCK_NAME" is not defined properly. Replaced with a dummy block.
    </p>

    <p>
        - they refer to a specific plugin and a specific block that caused the
        error.
    </p>

    <p>
        In case of a plugin error the whole plugin's category will most likely
        disappear from the toolbox. In case of a block error the affected
        blocks will be marked as invalid and will have a distinct look:
    </p>

    <img src="files/puzzles/puzzles-plugins-dummy-block.jpg" id="dummy_block_appearance" class="centered" style="max-width: 852px">
    <span class="img-caption">An invalid puzzle in the toolbox and on a workspace</span>

    <p>
        Here's the list of the most common plugin and block errors:
    </p>
    <br/>

    [anchor:plugin_errors_block_error_parsing_0]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): error parsing .block file - "This page contains the following errors:error on line ..."</h5>
    <p class="indented">
        This means that there are XML errors in the corresponding .block
        file preventing it from being parsed. For example, the missing ending
        &lt;script&gt; tag leads to such error:
        <code>
    &lt;script&gt;
    function template(block) {}
    function code(block) {}
        </code>
    </p>
    <br/>

    [anchor:plugin_errors_block_error_parsing_1]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): error parsing .block file - "ReferenceError (SyntaxError, TypeError, etc...) ..."</h5>
    <p class="indented">
        The error occurs in case if the code in the corresponding .block file's
        &lt;script&gt; element contains a JavaScript error of the kind specified
        in the error message.
    </p>
    <br/>

    [anchor:plugin_errors_block_error_validation_0]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): validation error - "TypeError: Child block does not have output or previous statement."</h5>
    <p class="indented">
        The block this error refers to has a child block plugged into it.
        However, the child block doesn't even have an <a href="manual/ru/puzzles/Plugins.html#block_file_template_block_connections">output or a previous connection</a>
        and therefore can not be used that way. This situation may happen either
        with puzzle blocks inside the plugin's toolbox <a href="manual/ru/puzzles/Plugins.html#init_plug_category">category</a>
        due to how they are configured in init.plug, and also this may happen
        with blocks actually used on a workspace.
    </p>
    <br/>

    [anchor:plugin_errors_block_error_validation_1]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): validation error - "Error: Connection checks failed. Input "PARENT_INPUT_NAME" connection on "PLUGIN_NAME/BLOCK_NAME" block (id="BLOCK_ID") expected TYPE_PARENT, found TYPE_CHILD"</h5>
    <p class="indented">
        The block this error refers to has a child block plugged into it but the
        parent's input slot and the child's output connection have incompatible
        <a href="manual/ru/puzzles/Plugins.html#block_file_template_input_output_type_checking">types</a>.
        This situation may happen either with puzzle blocks inside the plugin's
        toolbox <a href="manual/ru/puzzles/Plugins.html#init_plug_category">category</a>
        due to how they are configured in init.plug, and also this may happen
        with blocks actually used on a workspace.
    </p>
    <br/>

    [anchor:plugin_errors_block_error_validation_2]

    <h5>BlockError(PLUGIN_NAME/null): validation error - "TypeError: Unknown block type: PLUGIN_NAME/null"</h5>
    <p class="indented">
        This error means that the plugin's init.plug file refers to a block
        with no <a href="manual/ru/puzzles/Plugins.html#init_plug_available_puzzles">type attribute</a>
        specified, which is not allowed. For example, this won't work:
        <code>
    &lt;category name="My Awesome Plugin" color="green"&gt;
        &lt;block&gt;&lt;/block&gt;
    &lt;/category&gt;
        </code>
    </p>
    <br/>

    [anchor:plugin_errors_block_error_validation_3]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): validation error - "TypeError: Unknown block type: PLUGIN_NAME/BLOCK_NAME"</h5>
    <p class="indented">
        This error message usually appears after one of the
        <a href="manual/ru/puzzles/Plugins.html#plugin_errors_block_error_parsing_0">"error parsing .block file"</a>
        errors and simply indicates that the mentioned puzzle block wasn't
        properly loaded and initialized because of the original error.
    </p>
    <br/>

    [anchor:plugin_errors_block_error_template]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): error calling template() function ...</h5>
    <p class="indented">
        The corresponding .block file either has an incorrectly defined
        <a href="manual/ru/puzzles/Plugins.html#block_file_template">&lt;template&gt;</a> element
        or contains JavaScript errors inside its <a href="manual/ru/puzzles/Plugins.html#block_file_template">template()</a>
        function.
        <ul>
            <li>
                <b>BlockError(PLUGIN_NAME/BLOCK_NAME): error calling template() function - "TypeError: Found invalid FieldDropdown options."</b><br/>
                This particular error means that one of the puzzle's dropdown
                fields has an unnamed option. See
                <a href="manual/ru/puzzles/Plugins.html#block_file_template_adding_fields_dropdown">dropdown field</a>
                for more information.
            </li>
        </ul>
    </p>
    <br/>

    [anchor:plugin_errors_block_error_code]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): error calling code() function ...</h5>
    <p class="indented">
        The corresponding .block file contains JavaScript errors inside its
        <a href="manual/ru/puzzles/Plugins.html#block_file_code">code()</a>
        function.
    </p>
    <br/>

    [anchor:plugin_errors_plugin_error_parsing_0]

    <h5>PluginError(PLUGIN_NAME): error parsing init.plug file - "This page contains the following errors:error on line ..."</h5>
    <p class="indented">
        This means that there are XML errors in the plugin's init.plug file
        preventing it from being parsed. For example, the missing
        ending &lt;category&gt; tag leads to such error:
        <code>
    &lt;category name="MyAwesomePlugin" color="green"&gt;
        &lt;block type="myPuzzle"&gt;&lt;/block&gt;
        </code>
    </p>
    <br/>

    [anchor:plugin_errors_plugin_error_parsing_1]

    <h5>PluginError(PLUGIN_NAME): error parsing init.plug file - "ReferenceError (SyntaxError, TypeError, etc...) ..."</h5>
    <p class="indented">
        The error occurs in case if the code in the corresponding init.plug file's
        &lt;script&gt; element contains a JavaScript error of the kind specified
        in the error message.
    </p>
    <br/>

    [anchor:plugin_errors_plugin_error_code]

    <h5>PluginError(PLUGIN_NAME): error calling code() function ...</h5>
    <p class="indented">
        The plugin's init.plug file contains JavaScript errors inside its
        <a href="manual/ru/puzzles/Plugins.html#init_plug_script">code()</a>
        function.
    </p>
    <br/>

    [anchor:plugin_errors_dummy]

    <h5>Puzzle "PLUGIN_NAME/BLOCK_NAME" is not defined properly. Replaced with a dummy block.</h5>
    <p class="indented">
        This error message usually appears after one of BlockError and/or
        PluginError messages and simply indicates that the mentioned puzzle
        block wasn't properly loaded and initialized due to the original errors.
        In order to still be able to load puzzles and maintain their operability
        to some degree, such blocks (both in the plugin's toolbox category and
        on a workspace) are replaced with special dummy blocks. The example of
        what a dummy block looks like can be seen on <a href="manual/ru/puzzles/Plugins.html#dummy_block_appearance">this picture</a>.
    </p>
    <br/>


    [anchor:sharing_your_plugin]

    <h2>Sharing your Plugin</h2>

    <p>
        Once plugin developed and tested, feel free to share it by:
    </p>

    <ul>
        <li>Posting the link on the <a href="https://www.soft8soft.com/forum/plugins/" target="_blank">Verge3D Forum</a>.</li>
        <li>Getting mentioned in the <a href="manual/ru/introduction/Useful-links.html#third_party_plugins">Useful Links</a> directory (<a href="https://www.soft8soft.com/contact/" target="_blank">contact us</a>!).</li>
        <li>Sharing on social media by using <strong>#verge3d</strong> hashtag.</li>
        <li>Publishing on <a href="https://gumroad.com/" target="_blank">Gumroad</a> or similar resources.</li>
    </ul>


    <h2>Having Troubles with Puzzles?</h2>

    <p>Seek help on the <a href="https://www.soft8soft.com/forums/" target="_blank">forums</a>!</p>

  </article></body>
</html>
