<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <base href="../../../" />
    <script src="list.js"></script>
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css" />
  </head>
  <body>
    [page:Texture] &rarr;

    <h1>[name]</h1>

    <p class="desc">Creates a texture directly from raw data, width and height.</p>


    <h2>Constructor</h2>

    <h3>[name](data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy)</h3>
    <p>
      The data argument must be an [link:https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView ArrayBufferView].
      Further parameters correspond to the properties inherited from [page:Texture], where both magFilter and minFilter default to v3d.NearestFilter. The properties flipY and generateMipmaps are intially set to false.
    </p>
    <p>
      The interpretation of the data depends on type and format:
      If the type is v3d.UnsignedByteType, a Uint8Array will be useful for addressing the texel data.
      If the format is v3d.RGBAFormat, data needs four values for one texel; Red, Green, Blue and Alpha (typically the opacity). Similarly, v3d.RGBFormat specifies a format where only three values are used for each texel.<br />

      For the packed types, v3d.UnsignedShort4444Type, v3d.UnsignedShort5551Type or v3d.UnsignedShort565Type, all color components of one texel can be addressed as bitfields within an integer element of a Uint16Array.<br />

      In order to use the types v3d.FloatType and v3d.HalfFloatType, the WebGL implementation must support the respective extensions OES_texture_float and OES_texture_half_float. In order to use v3d.LinearFilter for component-wise, bilinear interpolation of the texels based on these types, the WebGL extensions OES_texture_float_linear or OES_texture_half_float_linear must also be present.
    </p>

    <h2>Example</h2>

    <code>
    // create a buffer with color data

    var size = width * height;
    var data = new Uint8Array(3 * size);

    var r = Math.floor(color.r * 255);
    var g = Math.floor(color.g * 255);
    var b = Math.floor(color.b * 255);

    for (var i = 0; i < size; i++) {

      var stride = i * 3;

      data[stride] = r;
      data[stride + 1] = g;
      data[stride + 2] = b;

    }

    // used the buffer to create a [name]

    var texture = new v3d.DataTexture(data, width, height, v3d.RGBFormat);
    </code>

    <h2>Properties</h2>

    <h3>[property:Image image]</h3>
    <p>
    Overridden with a record type holding data, width and height.
    </p>

    <h2>Methods</h2>


    [sourceHint]
  </body>
</html>
