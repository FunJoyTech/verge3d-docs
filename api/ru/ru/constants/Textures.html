<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <base href="../../../" />
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css" />
  </head>
  <body>
    <h1>Константы Текстур</h1>

    <h2>Режимы Маппинга</h2>
    <code>
    v3d.UVMapping
    v3d.CubeReflectionMapping
    v3d.CubeRefractionMapping
    v3d.EquirectangularReflectionMapping
    v3d.EquirectangularRefractionMapping
    v3d.CubeUVReflectionMapping
    v3d.CubeUVRefractionMapping
    </code>

    <p>
      Они определяют режим отображения текстуры. <br>
      [page:Constant UVMapping] — это режим по умолчанию, при котором текстура отображается с использованием UV-координат объекта.<br><br>

      Остальные определяют типы маппинга окруженающей среды.<br><br>

    [page:Constant CubeReflectionMapping] и [page:Constant CubeRefractionMapping] предназначены для использования с [page:CubeTexture CubeTexture], которая состоит из шести текстур, по одной для каждой грани куба. [page:Constant CubeReflectionMapping] — это значение по умолчанию для [page:CubeTexture CubeTexture]. <br><br>

    [page:Constant EquirectangularReflectionMapping] и [page:Constant EquirectangularRefractionMapping] предназначены для использования с равноугольной картой окружения. Также называемая картой широты, равноугольная текстура представляет собой 360-градусный вид вдоль горизонтальной центральной линии и 180-градусный вид вдоль вертикальной оси, причем верхний и нижний края изображения соответствуют северному и южному полюсам отображаемой сферы.<br><br>

    Смотрите пример [example:webgl_materials_envmaps materials / envmaps].
  </p>


    <h2>Режимы Обертывания</h2>
    <code>
    v3d.RepeatWrapping
    v3d.ClampToEdgeWrapping
    v3d.MirroredRepeatWrapping
    </code>
    <p>
      Они определяют свойства текстуры [page:Texture.wrapS wrapS] и [page:Texture.wrapT wrapT], которые определяют горизонтальное и вертикальное обертывание текстуры.<br><br>

      При использовании [page:constant RepeatWrapping] текстура будет просто повторяться до бесконечности.<br><br>

    [page:constant ClampToEdgeWrapping] по умолчанию.
    Последний пиксель текстуры растягивается до края сетки.<br><br>

    При использовании [page:constant MirroredRepeatWrapping] текстура будет повторяться до бесконечности, зеркально отражаясь при каждом повторении.
    </p>

    <h2>Magnification Filters (Фильтры Увеличения)</h2>
    <code>
    v3d.NearestFilter
    v3d.LinearFilter
    </code>

    <p>
      Для использования со свойством [page:Texture.magFilter magFilter] текстуры, они определяют функцию увеличения текстуры, которая будет использоваться, когда пиксель, на который накладывается текстура, имеет площадь меньше или равную одному элементу текстуры (текселу).<br><br>

      [page:constant NearestFilter] возвращает значение элемента текстуры, который является ближайшим (по расстоянию Манхэттена) к указанным координатам текстуры.<br><br>

      [page:constant LinearFilter] используется по умолчанию и возвращает средневзвешенное значение четырех элементов текстуры, которые ближе всего к указанным координатам текстуры, и может включать элементы, обернутые или повторенные из других частей текстуры, в зависимости от значений [page:Texture.wrapS wrapS] и [page:Texture.wrapT wrapT], а также от точного отображения.
    </p>

    <h2>Minification Filters (Фильтры Уменьшения)</h2>
    <code>
    v3d.NearestFilter
    v3d.NearestMipmapNearestFilter
    v3d.NearestMipmapLinearFilter
    v3d.LinearFilter
    v3d.LinearMipmapNearestFilter
    v3d.LinearMipmapLinearFilter
    </code>

    <p>
      Для использования со свойством [page:Texture.minFilter minFilter] текстуры, они определяют функцию минимизации текстуры, которая используется всякий раз, когда пиксель, на который наносится текстура, отображается на область, превышающую один элемент текстуры (тексель).<br><br>

      В дополнение к [page:constant NearestFilter] и [page:constant LinearFilter] для минификации можно использовать следующие четыре функции:<br><br>

      [page:constant NearestMipmapNearestFilter] выбирает мипмапу, наиболее точно соответствующую размеру текстурируемого пикселя, и использует критерий [page:constant NearestFilter] (ближайший к центру пикселя тексель) для получения значения текстуры.<br><br>

      [page:constant NearestMipmapLinearFilter] выбирает два отображения, которые наиболее точно соответствуют размеру текстурируемого пикселя, и использует критерий [page:constant NearestFilter] для получения значения текстуры из каждого отображения. Окончательное значение текстуры является средневзвешенным значением этих двух значений.<br><br>

      [page:constant LinearMipmapNearestFilter] выбирает мипмапу, наиболее точно соответствующую размеру текстурируемого пикселя, и использует критерий [page:constant LinearFilter] (средневзвешенное значение четырех текселей, наиболее близких к центру пикселя) для получения значения текстуры.<br><br>

      [page:constant LinearMipmapLinearFilter] используется по умолчанию и выбирает два отображения, которые наиболее точно соответствуют размеру текстурируемого пикселя, и использует критерий [page:constant LinearFilter] для получения значения текстуры из каждого отображения. Окончательное значение текстуры является средневзвешенным значением этих двух значений.<br><br>

      Смотрите пример [example:webgl_materials_texture_filters materials / texture / filters].
    </p>

    <h2>Types</h2>
    <code>
    v3d.UnsignedByteType
    v3d.ByteType
    v3d.ShortType
    v3d.UnsignedShortType
    v3d.IntType
    v3d.UnsignedIntType
    v3d.FloatType
    v3d.HalfFloatType
    v3d.UnsignedShort4444Type
    v3d.UnsignedShort5551Type
    v3d.UnsignedShort565Type
    v3d.UnsignedInt248Type
    </code>
    <p>
      Используется со свойством [page:Texture.type type] текстуры, которое должно соответствовать правильному формату. Подробности см. ниже.<br><br>

    [page:constant UnsignedByteType] по умолчанию.
    </p>

    <h2>Formats</h2>
    <code>
    v3d.AlphaFormat
    v3d.RedFormat
    v3d.RedIntegerFormat
    v3d.RGFormat
    v3d.RGIntegerFormat
    v3d.RGBFormat
    v3d.RGBIntegerFormat
    v3d.RGBAFormat
    v3d.RGBAIntegerFormat
    v3d.LuminanceFormat
    v3d.LuminanceAlphaFormat
    v3d.RGBEFormat
    v3d.DepthFormat
    v3d.DepthStencilFormat
    </code>
    <p>
      Для использования со свойством [page:Texture.format format] текстуры, они определяют, как элементы двухмерной текстуры, или *texels*(тексели), считываются шейдерами.<br><br>

    [page:constant AlphaFormat] отбрасывает красный, зеленый и синий компоненты и считывает только альфа-компонент.<br><br>

    [page:constant RedFormat] отбрасывает зеленый и синий компоненты и считывает только красный компонент.<br><br>

    [page:constant RedIntegerFormat] отбрасывает зеленый и синий компоненты и считывает только красный компонент.
    Тексели считываются как целые числа, а не с плавающей точкой.
    (может использоваться только с рендерингом WebGL 2).
    <br><br>

    [page:constant RGFormat] отбрасывает альфа- и синие компоненты и считывает красную и зеленую компоненты.
    (может использоваться только с рендерингом WebGL 2).
    <br><br>

    [page:constant RGIntegerFormat] отбрасывает альфа- и синие компоненты и считывает красную и зеленую компоненты.
    Тексели считываются как целые числа, а не с плавающей точкой.
    (может использоваться только с рендерингом WebGL 2).
    <br><br>

    [page:constant RGBFormat] отбрасывает альфа-компоненты и считывает красные, зеленые и синие компоненты.<br><br>

    [page:constant RGBIntegerFormat] отбрасывает альфа-компоненты и считывает красные, зеленые и синие компоненты.
    (может использоваться только с рендерингом WebGL 2).
    <br><br>

    [page:constant RGBAFormat] используется по умолчанию и считывает красный, зеленый, синий и альфа-компоненты.<br><br>

    [page:constant RGBAIntegerFormat] используется по умолчанию и считывает красный, зеленый, синий и альфа-компоненты.
    Тексели считываются как целые числа, а не с плавающей точкой.
    (может использоваться только с рендерингом WebGL 2).
    <br><br>

    [page:constant LuminanceFormat] считывает каждый элемент как один компонент яркости.
    Затем это значение преобразуется в плавающую точку, ограничивается в диапазоне [0,1], а затем собирается в RGBA-элемент, помещая значение яркости в красный, зеленый и синий каналы и присоединяя 1.0 к альфа-каналу.<br><br>

    [page:constant LuminanceAlphaFormat] считывает каждый элемент как двойное значение яркости/альфа-канала. Происходит тот же процесс, что и для [page:constant LuminanceFormat], за исключением того, что альфа-канал может иметь значения, отличные от *1.0*.<br><br>

    [page:constant RGBEFormat] идентичен [page:constant RGBAFormat].<br><br>

    [page:constant DepthFormat] считывает каждый элемент как одно значение глубины, преобразует его в значение с плавающей точкой и зажимает в диапазон [0,1].
    Это значение по умолчанию для [page:DepthTexture DepthTexture].<br><br>

    [page:constant DepthStencilFormat] каждый элемент представляет собой пару значений глубины и стенсиля.
    Компонент глубины пары интерпретируется как в [page:constant DepthFormat]. Компонент стенсиля интерпретируется на основе внутреннего формата "глубина + стенсиль".
    <br><br>

    Обратите внимание, что текстура должна иметь правильное значение [page:Texture.type type], как описано выше.
    Ознакомьтес с [link:https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext/texImage2D WebGLRenderingContext.texImage2D] для деталей.
    </p>

    <h2>DDS / ST3C Форматы Сжатия Текстур</h2>
    <code>
    v3d.RGB_S3TC_DXT1_Format
    v3d.RGBA_S3TC_DXT1_Format
    v3d.RGBA_S3TC_DXT3_Format
    v3d.RGBA_S3TC_DXT5_Format
    </code>
    <p>
      Для использования со свойством [page:CompressedTexture CompressedTexture] [page:Texture.format format] свойства [page:Texture.format format] требуют поддержки для
    [link:https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/ WEBGL_compressed_texture_s3tc]
    расширение. <br><br>

    Через это расширение доступны четыре [link:https://en.wikipedia.org/wiki/S3_Texture_Compression S3TC] формата. К ним относятся:<br>
    [page:constant RGB_S3TC_DXT1_Format]: Сжатое в DXT1 изображение в формате RGB.<br>
    [page:constant RGBA_S3TC_DXT1_Format]: DXT1-сжатое изображение в формате RGB с простым включением/выключением альфа-значения.<br>
    [page:constant RGBA_S3TC_DXT3_Format]: DXT3-сжатое изображение в формате RGBA-изображения. По сравнению с 32-битной RGBA-текстурой оно обеспечивает сжатие 4:1.<br>
    [page:constant RGBA_S3TC_DXT5_Format]: DXT5-сжатое изображение в формате RGBA. Оно также обеспечивает сжатие 4:1, но отличается от сжатия DXT3 тем, как выполняется альфа-сжатие.<br>
    </p>

    <h2>PVRTC Формат Сжатия Текстур</h2>
    <code>
    v3d.RGB_PVRTC_4BPPV1_Format
    v3d.RGB_PVRTC_2BPPV1_Format
    v3d.RGBA_PVRTC_4BPPV1_Format
    v3d.RGBA_PVRTC_2BPPV1_Format
    </code>
    <p>
      Для использования свойства [page:CompressedTexture CompressedTexture] [page:Texture.format format] для [page:Texture.format format] требуется поддержка[link:https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/ WEBGL_compressed_texture_pvrtc]
      расширения. <br>
      PVRTC обычно доступен только на мобильных устройствах с чипсетами PowerVR, а это в основном устройства Apple.<br><br>

      Через это расширение доступны четыре [link:https://en.wikipedia.org/wiki/PVRTC PVRTC] формата. К ним относятся:<br>
    [page:constant RGB_PVRTC_4BPPV1_Format]: Сжатие RGB в 4-битном режиме. Один блок на каждые 4×4 пикселя.<br>
    [page:constant RGB_PVRTC_2BPPV1_Format]: Сжатие RGB в 2-битном режиме. Один блок на каждые 8×4 пикселя.<br>
    [page:constant RGBA_PVRTC_4BPPV1_Format]: Сжатие RGBA в 4-битном режиме. Один блок на каждые 4×4 пикселя.<br>
    [page:constant RGBA_PVRTC_2BPPV1_Format]: Сжатие RGBA в 2-битном режиме. Один блок на каждые 8×4 пикселя.<br>
    </p>

    <h2>ETC Формат Сжатия Текстур</h2>
    <code>
    v3d.RGB_ETC1_Format
    v3d.RGB_ETC2_Format
    v3d.RGBA_ETC2_EAC_Format
    </code>
    <p>
      Для использования со свойством [page:CompressedTexture CompressedTexture] [page:Texture.format format] свойства [page:Texture.format format] требуют поддержки для [link:https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/ WEBGL_compressed_texture_etc1]
    (ETC1) или [link:https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/ WEBGL_compressed_texture_etc]
    (ETC2) расширения. <br><br>
    </p>

    <h2>ASTC Формат Сжатия Текстур</h2>
    <code>
    v3d.RGBA_ASTC_4x4_Format
    v3d.RGBA_ASTC_5x4_Format
    v3d.RGBA_ASTC_5x5_Format
    v3d.RGBA_ASTC_6x5_Format
    v3d.RGBA_ASTC_6x6_Format
    v3d.RGBA_ASTC_8x5_Format
    v3d.RGBA_ASTC_8x6_Format
    v3d.RGBA_ASTC_8x8_Format
    v3d.RGBA_ASTC_10x5_Format
    v3d.RGBA_ASTC_10x6_Format
    v3d.RGBA_ASTC_10x8_Format
    v3d.RGBA_ASTC_10x10_Format
    v3d.RGBA_ASTC_12x10_Format
    v3d.RGBA_ASTC_12x12_Format
    v3d.SRGB8_ALPHA8_ASTC_4x4_Format
    v3d.SRGB8_ALPHA8_ASTC_5x4_Format
    v3d.SRGB8_ALPHA8_ASTC_5x5_Format
    v3d.SRGB8_ALPHA8_ASTC_6x5_Format
    v3d.SRGB8_ALPHA8_ASTC_6x6_Format
    v3d.SRGB8_ALPHA8_ASTC_8x5_Format
    v3d.SRGB8_ALPHA8_ASTC_8x6_Format
    v3d.SRGB8_ALPHA8_ASTC_8x8_Format
    v3d.SRGB8_ALPHA8_ASTC_10x5_Format
    v3d.SRGB8_ALPHA8_ASTC_10x6_Format
    v3d.SRGB8_ALPHA8_ASTC_10x8_Format
    v3d.SRGB8_ALPHA8_ASTC_10x10_Format
    v3d.SRGB8_ALPHA8_ASTC_12x10_Format
    v3d.SRGB8_ALPHA8_ASTC_12x12_Format
    </code>
    <p>
      Для использования со свойством [page:CompressedTexture CompressedTexture] [page:Texture.format format], требуется поддержка [link:https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/ WEBGL_compressed_texture_astc] разрешения. <br><br>
    </p>

    <h2>Внутренние Форматы</h2>
    <code>
    'ALPHA'
    'RGB'
    'RGBA'
    'LUMINANCE'
    'LUMINANCE_ALPHA'
    'RED_INTEGER'
    'R8'
    'R8_SNORM'
    'R8I'
    'R8UI'
    'R16I'
    'R16UI'
    'R16F'
    'R32I'
    'R32UI'
    'R32F'
    'RG8'
    'RG8_SNORM'
    'RG8I'
    'RG8UI'
    'RG16I'
    'RG16UI'
    'RG16F'
    'RG32I'
    'RG32UI'
    'RG32F'
    'RGB565'
    'RGB8'
    'RGB8_SNORM'
    'RGB8I'
    'RGB8UI'
    'RGB16I'
    'RGB16UI'
    'RGB16F'
    'RGB32I'
    'RGB32UI'
    'RGB32F'
    'RGB9_E5'
    'SRGB8'
    'R11F_G11F_B10F'
    'RGBA4'
    'RGBA8'
    'RGBA8_SNORM'
    'RGBA8I'
    'RGBA8UI'
    'RGBA16I'
    'RGBA16UI'
    'RGBA16F'
    'RGBA32I'
    'RGBA32UI'
    'RGBA32F'
    'RGB5_A1'
    'RGB10_A2'
    'RGB10_A2UI'
    'SRGB8_ALPHA8'
    'DEPTH_COMPONENT16'
    'DEPTH_COMPONENT24'
    'DEPTH_COMPONENT32F'
    'DEPTH24_STENCIL8'
    'DEPTH32F_STENCIL8'
    </code>

    <p>

      Внимание: изменение внутреннего формата текстуры будет влиять на текстуру только при использовании контекста рендеринга WebGL 2.<br><br>

      Для использования со свойством [page:Texture.internalFormat internalFormat] текстуры, они определяют, как элементы текстуры, или *тексели*, хранятся на GPU.<br><br>

    [page:constant R8] хранит красный компонент в 8 битах.<br><br>

    [page:constant R8_SNORM] хранит красный компонент в 8 битах. Компонент хранится в нормализованном виде. <br><br>

    [page:constant R8I]  хранит красный компонент в 8 битах. Компонент хранится как целое число. <br><br>

    [page:constant R8UI]  хранит красный компонент в 8 битах. Компонент хранится как целое число без знака. <br><br>

    [page:constant R16I] хранит красный компонент в 16 битах. Компонент хранится как целое число. <br><br>

    [page:constant R16UI] хранит красный компонент в 16 битах. Компонент хранится как целое число без знака. <br><br>

    [page:constant R16F] хранит красный компонент в 16 битах. Компонент хранится в формате с плавающей точкой. <br><br>

    [page:constant R32I] хранит красный компонент в 32 битах. Компонент хранится как целое число. <br><br>

    [page:constant R32UI] хранит красный компонент в 32 битах. Компонент хранится как целое число без знака. <br><br>

    [page:constant R32F] хранит красный компонент в 32 битах. Компонент хранится в формате с плавающей точкой.<br><br>

    [page:constant RG8]хранит красный компонент в 32 битах.<br><br>

    [page:constant RG8_SNORM] хранит красный и зеленый компоненты по 8 бит каждый.
    Каждый компонент хранится в нормализованном виде.
    <br><br>

    [page:constant RG8I] хранит красный и зеленый компоненты по 8 бит каждый.
    Каждый компонент хранится как целое число.
    <br><br>

    [page:constant RG8UI] хранит красный и зеленый компоненты по 8 бит каждый.
    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant RG16I] хранит красный и зеленый компоненты по 16 бит каждый.
    Каждый компонент хранится как целое число.
    <br><br>

    [page:constant RG16UI] хранит красный и зеленый компоненты по 16 бит каждый.
    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant RG16F] хранит красный и зеленый компоненты по 16 бит каждый.
    Каждый компонент хранится в формате с плавающей точкой.
    <br><br>

    [page:constant RG32I] хранит красный и зеленый компоненты по 32 бита каждый.
    Каждый компонент хранится как целое число.
    <br><br>

    [page:constant RG32UI] хранит красный и зеленый компоненты в 32 битах.
    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant RG32F] хранит красный и зеленый компоненты в 32 битах.
    Каждый компонент хранится в формате с плавающей точкой.
    <br><br>

    [page:constant RGB8] хранит красный, зеленый и синий компоненты по 8 бит каждый.

    [page:constant RGB8_SNORM] хранит красный, зеленый и синий компоненты по 8 бит каждый.
    Каждый компонент хранится в нормализованном виде.
    <br><br>

    [page:constant RGB8I] хранит красный, зеленый и синий компоненты по 8 бит каждый.
    Каждый компонент хранится как целое число.
    <br><br>

    [page:constant RGB8UI] хранит красный, зеленый и синий компоненты по 8 бит каждый.
    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant RGB16I] хранит красный, зеленый и синий компоненты по 16 бит каждый.
    Каждый компонент хранится как целое число.
    <br><br>

    [page:constant RGB16UI] хранит красный, зеленый и синий компоненты по 16 бит каждый.
    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant RGB16F] хранит красный, зеленый и синий компоненты по 16 бит каждый.
    Каждый компонент хранится в формате с плавающей точкой
    <br><br>

    [page:constant RGB32I] хранит красный, зеленый и синий компоненты по 32 бита каждый.
    Каждый компонент хранится как целое число.
    <br><br>

    [page:constant RGB32UI] хранит красный, зеленый и синий компоненты по 32 бита каждый.
    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant RGB32F] хранит красный, зеленый и синий компоненты по 32 бита каждый.
    Каждый компонент хранится в формате с плавающей точкой
    <br><br>

    [page:constant R11F_G11F_B10F] хранит красный, зеленый и синий компоненты соответственно в 11 битах, 11 битах и 10 битах.
    Каждый компонент хранится в формате с плавающей точкой.
    <br><br>

    [page:constant RGB565] хранит красный, зеленый и синий компоненты соответственно в 5 битах, 6 битах и 5 битах.<br><br>

    [page:constant RGB9_E5] хранит красный, зеленый и синий компоненты по 9 бит каждый.<br><br>

    [page:constant RGBA8]хранит красный, зеленый, синий и альфа-компоненты по 8 бит каждый.<br><br>

    [page:constant RGBA8_SNORM] хранит красный, зеленый, синий и альфа компоненты в 8 битах.
    Every component is stored as normalized.
    <br><br>

    [page:constant RGBA8I] хранит красный, зеленый, синий и альфа-компоненты по 8 бит каждый.
    Каждый компонент хранится как целое число.
    <br><br>

    [page:constant RGBA8UI] хранит красный, зеленый, синий и альфа компоненты в 8 битах.
    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant RGBA16I] хранит красный, зеленый, синий и альфа компоненты в 16 битах.
    Каждый компонент хранится как целое число.
    <br><br>

    [page:constant RGBA16UI] хранит красный, зеленый, синий и альфа компоненты в 16 битах.
    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant RGBA16F] хранит красный, зеленый, синий и альфа компоненты в 16 битах.
    Каждый компонент хранится в формате с плавающей точкой.
    <br><br>

    [page:constant RGBA32I] хранит красный, зеленый, синий и альфа компоненты в 32 битах.
    Каждый компонент хранится как целое число.
    <br><br>

    [page:constant RGBA32UI] хранит красный, зеленый, синий и альфа компоненты в 32 битах.
    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant RGBA32F] хранит красный, зеленый, синий и альфа компоненты в 32 битах.
    Каждый компонент хранится в формате с плавающей точкой.
    <br><br>

    [page:constant RGB5_A1] хранит красный, зеленый, синий и альфа компоненты соответственно в 5 битах, 5 битах, 5 битах и 1 бите.<br><br>

    [page:constant RGB10_A2] хранит красный, зеленый, синий и альфа компоненты соответственно в 10 битах, 10 битах, 10 битах и 2 битах.<br><br>

    [page:constant RGB10_A2UI] хранит красный, зеленый, синий и альфа компоненты соответственно в 10 битах, 10 битах, 10 битах и 2 битах.

    Каждый компонент хранится как целое число без знака.
    <br><br>

    [page:constant SRGB8]хранит красный, зеленый и синюий компоненты по 8 бит.<br><br>

    [page:constant SRGB8_ALPHA8] хранит красный, зеленый, синий и альфа-компоненты по 8 бит каждый.<br><br>

    [page:constant DEPTH_COMPONENT16] хранит компонент глубины в 16 битах.<br><br>

    [page:constant DEPTH_COMPONENT24] хранит компонент глубины в 24 битах.<br><br>

    [page:constant DEPTH_COMPONENT32F] хранит компонент глубины в 32 битах. Компонент хранится в формате с плавающей точкой.<br><br>

    [page:constant DEPTH24_STENCIL8] хранит компоненты глубины и стенсиля соответственно в 24 битах и 8 битах.
    Компонент стенсиля хранится как целое число без знака.
    <br><br>

    [page:constant DEPTH32F_STENCIL8] хранит компоненты глубины и стенсиля соответственно в 32 битах и 8 битах.
    Компонент глубины хранится как плавающая точка, а компонент стенсиля - как целое число без знака.
    <br><br>

    Обратите внимание, что текстура должна иметь правильный набор [page:Texture.type type], а также правильный формат [page:Texture.format format].

    Смотрите [link:https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext/texImage2D WebGLRenderingContext.texImage2D], и
    [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/texImage3D WebGL2RenderingContext.texImage3D],
    для получения дополнительной информации о возможных комбинациях [page:Texture.format format], [page:Texture.internalFormat internalFormat],
    и [page:Texture.type type].<br><br>

    Для получения более подробной информации о внутренних форматах вы также можете обратиться непосредственно к разделу [link:https://www.khronos.org/registry/webgl/specs/latest/2.0/ WebGL2 Specification] и к [link:https://www.khronos.org/registry/OpenGL/specs/es/3.0/es_spec_3.0.pdf OpenGL ES 3.0 Specification].
    </p>

    <h2>Encoding</h2>
    <code>
    v3d.LinearEncoding
    v3d.sRGBEncoding
    v3d.GammaEncoding
    v3d.RGBEEncoding
    v3d.LogLuvEncoding
    v3d.RGBM7Encoding
    v3d.RGBM16Encoding
    v3d.RGBDEncoding
    v3d.BasicDepthPacking
    v3d.RGBADepthPacking
    </code>
    <p>
      Для использования со свойством [page:Texture.encoding encoding] текстуры.<br><br>

      Если тип кодировки изменен после того, как текстура уже использовалась материалом, необходимо установить [page:Material.needsUpdate Material.needsUpdate] в *true*, чтобы материал перекомпилировался.<br><br>

    [page:constant LinearEncoding] по умолчанию.
    Значения, отличные от этого, действительны только для карты материала, envMap и emissiveMap.
    </p>

    [sourceHint]
  </body>
</html>
