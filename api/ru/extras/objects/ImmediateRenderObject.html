<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <base href="../../../../" />
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css" />
  </head>
  <body>
    [page:Object3D] &rarr;

    <h1>[name]</h1>

    <p class="desc">
      Этот экспериментальный класс обеспечивает быстрый путь кода для рендеринга мешей с часто обновляемыми геометрическими данными. Когда рендерер встречает экземпляр [name], он заботится только о самых примитивных операциях рендеринга (например, привязка атрибутов вершин, определение правильной шейдерной программы или выполнение фактического вызова отрисовки). Такие функции, как выборка фрагмента изображения, рендеринг сетки или использование нескольких материалов, не поддерживаются. Кроме того, [name] может использоваться только для рендеринга треугольников.
    </p>

    <p class="desc">
      [name] не работает с экземплярами [page:BufferGeometry] или [page:Geometry]. Необработанные геометрические данные должны сохраняться как свойства [name].
    </p>

    <p class="desc">
      Использование [name] имеет смысл только в том случае, если вы обновляете данные геометрии по кадрам. Тогда вы сможете воспользоваться преимуществами более быстрого пути кода по сравнению со стандартной логикой рендеринга мешей.
    </p>

    <h2>Примеры</h2>
    <p>
      [example:webgl_marchingcubes Marching Cubes]
    </p>

    <h2>Конструктор</h2>


    <h3>[name]([param:Material material])</h3>
    <p>
    [page:Material material] — Материал [name].
    </p>

    <h2>Свойства</h2>
    <p>Общие свойства смотрите в базовом классе [page:Object3D].</p>

    <h3>[property:Boolean material]</h3>
    <p>
      Материал [name]. Назначение нескольких материалов не поддерживается.
    </p>

    <h3>[property:Boolean hasPositions]</h3>
    <p>
      Определены ли данные о положении или нет. По умолчанию *false*.
    </p>

    <h3>[property:Boolean hasNormals]</h3>
    <p>
      Определены ли данные нормалей или нет. По умолчанию *false*.
    </p>

    <h3>[property:Boolean hasColors]</h3>
    <p>
      Определены ли данные цвета или нет. По умолчанию *false*.
    </p>

    <h3>[property:Boolean hasUvs]</h3>
    <p>
      Определены ли координаты текстуры или нет. По умолчанию *false*.
    </p>

    <h3>[property:Float32Array positionArray]</h3>
    <p>
      Буфер, в котором хранятся данные о положении. По умолчанию *null*.
    </p>

    <h3>[property:Float32Array normalArray]</h3>
    <p>
      Буфер, в котором хранятся обычные данные. По умолчанию *null*.
    </p>

    <h3>[property:Float32Array colorArray]</h3>
    <p>
      Буфер, в котором хранятся данные о цвете. По умолчанию *null*.
    </p>

    <h3>[property:Float32Array uvArray]</h3>
    <p>
      Буфер, в котором хранятся координаты текстуры. По умолчанию *null*.
    </p>

    <h3>[property:Integer count]</h3>
    <p>
      Количество примитивов для рендеринга. По умолчанию *0*. Это свойство будет установлено в *0* после каждого рендеринга, поэтому обычно вы устанавливаете его в процессе выполнения [page:.render]().
    </p>

    <h2>Методы</h2>

    <p>Общие методы смотрите в базовом классе [page:Object3D].</p>

    <h3>[method:null render]([param:Function renderCallback])</h3>
    <p>
    renderCallback -- Функция для рендера сгенерированных геометрических данных.
    </p>
    <p>
      Этот метод должен быть реализован производным классом [name]. Обычно вам необходимо реализовать логику обновления буфера вершин и выполнить *renderCallback* в конце вашей реализации.
    </p>

    [sourceHint]
  </body>
</html>
